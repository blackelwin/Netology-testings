# DevOps-Netology

## Домашнее задание к занятию "3.3. Операционные системы. Лекция 1"

1. `strace /bin/bash -c 'cd /tmp'` вызов, относящийся к `cd` - `chdir`.

   `strace sh` и дальнейший ввод `cd /tmp` детально отображают, что произошло чтение команды `cd /tmp` и дальнейший вызов `chdir /tmp`.
2. Изучив вывод `strace file`, обнаружил строки `openat` сигнализирующие об открытии файлов. Рассмотрев более детально, пришел к выводу, что база данных `file` находится в `/usr/share/misc/magic.mgc`. 

   Строка, соответствующая выводу - `openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3`

   `cat /usr/share/misc/magic.mgc` это подтверждает.

   `file /usr/share/misc/magic.mgc` сообщает, что это всего лишь ярлык (символическая ссылка) к файлу magic.mgc в другой директории.
3. На примере редактора VI - создал файл test.txt. Открыл его, хоткеем ctrl+Z отправил в фон, удалил файл `rm test.txt`. `bg` и `jobs` отображают фоновый файл test.txt.
   `lsof | grep vi` нашел PID (3122) открытого файла (.test.txt.swp) и его дескриптор (4)

   Перенаправил `''` через `/proc` - `echo '' >/proc/3122/fd/4`
4. Зомби не занимают памяти (как процессы-сироты), но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.Зомби не могут принимать сигналы, и поэтому их нельзя убрать с помощью утилиты или вызова kill. Убрать их может либо родительский процесс, либо его завершение.
5. Без root доступа команда `dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc` не запустилась. После перехода в root первые вызовы:
   ```
     PID    COMM               FD ERR PATH
     1      systemd            12   0 /proc/617/cgroup
     862    vminfo              5   0 /var/run/utmp
     632    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
     632    dbus-daemon        21   0 /usr/share/dbus-1/system-services
     632    dbus-daemon        -1   2 /lib/dbus-1/system-services
     632    dbus-daemon        21   0 /var/lib/snapd/dbus-1/system-services/
   ```
6. В man не нашел информацию об альтернативном вызове `uname -a` (ни в `man uname`, ни в `man proc`). В сети интернет нашел `Часть информации из структуры utsname может быть получена также через sysctl и через /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}`
7. && - оператор AND, выполняющий команды последовательно и только в том случае, если предыдущая команда выполнена успешно (exit code=0).

   ; - оператор, выполняющий команды последовательно без проверки результата выполнения предыдущей команды.

   set - устанавливает или убирает значения опций оболочки и позиционных параметров. `set -e` - сразу прерывает выполнение команды, если команда выполнена не успешно (exit code != 0), поэтому выполнение команды `set -e` совместно с оператором && бессмыслено, потому что при ошибке выполнение команд немедленно прекратится.
8. e - незамедлительное прерывание выполнения, если выполнение команда закончится не успешно (не 0);

   u - считать неустановленные/не заданные параметры как ошибки;

   x - выводить команды и их аргументы как они были выполнены;

   o pipefail - вернуть код возврата команд, ненулевой при последней команды или 0 для успешного выполнения команд.
9. `ps -o stat` выдал мне:
     ```
     STAT
     S
     R+
     ```
   
    S - спящие, ожидающие действия для завершения
    R - запущенные или ожидающие очереди запуска 
